<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Times Tables Game</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap');
    :root {
      --bg: #f5efe6;
      --panel: #fbf3e7;
      --card: #f2e3d1;
      --text: #3f2f2f;
      --muted: #8f7c6a;
      --primary: #cf8c4c;
      --primary-2: #e4a869;
      --success: #4aa564;
      --danger: #c45b4d;
      --warning: #dba45b;
      --shadow: 0 12px 28px rgba(120,90,60,0.24), 0 6px 12px rgba(120,90,60,0.18);
      --radius: 14px;
      --admin-toggle-bg: #c9823a;
      --admin-bg: #fff7ec;
      --bg-image: none;
    }

    html, body {
      height: 100%;
    }

    body {
      margin: 0;
      color: var(--text);
      font-family: "Nunito", ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
        Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background:
                  var(--bg-image),
                  radial-gradient(900px 620px at 10% -10%, rgba(223,182,128,0.25) 0%, transparent 65%),
                  radial-gradient(900px 620px at 120% 110%, rgba(198,157,107,0.25) 0%, transparent 65%),
                  linear-gradient(160deg, #f9f1e6 0%, #f2e4d3 100%);
    }

    /* Consistent sizing model prevents width mismatches */
    *, *::before, *::after { box-sizing: border-box; }

    /* Keep layout width stable when content height changes (prevents viewport width shifts
       due to scrollbar appearing/disappearing) */
    html { overflow-y: scroll; }

    .wrap {
      min-height: 100%;
      display: grid;
      grid-template-rows: auto 1fr auto;
    }

    header {
      padding: 18px 20px 8px;
      text-align: center;
    }

    .title {
      font-weight: 800;
      letter-spacing: 0.3px;
      font-size: clamp(20px, 2.3vw, 32px);
    }

    .subtle {
      color: var(--muted);
      font-size: 0.95rem;
      margin-top: 4px;
    }

    .container {
      max-width: 920px;
      width: 100%;
      margin: 0 auto;
      padding: 16px;
      display: grid;
      gap: 16px;
      grid-template-columns: 1fr;
    }

    .game-card { width: 100%; }

    .btn-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-top: 4px;
      align-items: center; /* avoid stretching to tallest button */
    }

    .btn {
      background: linear-gradient(180deg, rgba(207,140,76,0.95), rgba(228,168,105,0.9));
      color: #fff9f2;
      border: none;
      border-radius: 10px;
      padding: 10px 18px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: 0.2px;
      box-shadow: var(--shadow);
      transition: transform 120ms ease, filter 120ms ease, opacity 120ms ease;
      white-space: nowrap; /* keep labels on one line */
    }
    .btn:hover { filter: brightness(1.03); }
    .btn:active { transform: translateY(1px); }
    .btn.secondary {
      background: linear-gradient(180deg, rgba(203,149,91,0.95), rgba(177,120,70,0.9));
    }
    .btn.ghost {
      background: transparent;
      border: 1px solid rgba(207,140,76,0.4);
      color: var(--text);
      box-shadow: none;
    }

    .game-card {
      background: linear-gradient(180deg, rgba(255,255,255,0.86), rgba(243,219,188,0.78));
      border: 1px solid rgba(120,90,60,0.18);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 20px;
      display: grid;
      gap: 18px;
    }

    .collection {
      background: rgba(255,255,255,0.7);
      border: 1px solid rgba(186,152,112,0.25);
      border-radius: 12px;
      padding: 14px 16px 16px;
      display: grid;
      gap: 12px;
    }
    .collection-title {
      margin: 0;
      font-size: 1rem;
      font-weight: 700;
      letter-spacing: 0.3px;
      color: var(--text);
    }
    .collection-body {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      min-height: 42px;
    }
    .collection-item {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.85);
      border: 1px solid rgba(186,152,112,0.32);
      font-size: 1rem;
      box-shadow: 0 6px 12px rgba(120,90,60,0.12);
    }
    .collection-item .emoji {
      font-size: 1.3rem;
    }
    .collection-item .count {
      font-size: 0.85rem;
      color: var(--muted);
    }
    .collection-empty {
      font-size: 0.9rem;
      color: rgba(77,60,46,0.75);
    }

    .score {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: center;
      font-size: 0.95rem;
      color: var(--muted);
    }
    .score strong { color: var(--text); }

    .equation {
      text-align: center;
      font-size: clamp(34px, 6.5vw, 64px);
      font-weight: 800;
      letter-spacing: 0.5px;
      padding: 8px 0 2px;
    }

    :root { --opt-h: 56px; --opt-gap: 12px; }
    .options {
      display: grid;
      gap: var(--opt-gap);
      grid-auto-flow: row;
      min-height: calc(var(--opt-h) * 2 + var(--opt-gap)); /* reserve space for up to 2 rows */
    }
    /* Layout by number of options */
    .options.opts-2 { grid-template-columns: repeat(2, 1fr); }
    .options.opts-3 { grid-template-columns: repeat(3, 1fr); }
    .options.opts-4 { grid-template-columns: repeat(2, 1fr); }
    .options.opts-6 { grid-template-columns: repeat(3, 1fr); }

    .option {
      background: linear-gradient(180deg, rgba(255,255,255,0.7), rgba(244,224,198,0.85));
      border: 1px solid rgba(124,103,84,0.25);
      border-radius: 12px;
      color: var(--text);
      padding: 14px 12px;
      cursor: pointer;
      font-weight: 700;
      font-size: 1.1rem;
      text-align: center;
      transition: transform 120ms ease, background 160ms ease, border 160ms ease, opacity 160ms ease;
      user-select: none;
      min-height: var(--opt-h);
      display: flex; align-items: center; justify-content: center;
    }
    .option:hover { transform: translateY(-1px); }
    .option:active { transform: translateY(0); }
    .option.correct {
      background: linear-gradient(180deg, rgba(74,165,100,0.2), rgba(74,165,100,0.1));
      border-color: rgba(74,165,100,0.45);
      box-shadow: 0 0 0 3px rgba(74,165,100,0.18) inset;
    }
    .option.wrong {
      background: linear-gradient(180deg, rgba(196,91,77,0.2), rgba(196,91,77,0.1));
      border-color: rgba(196,91,77,0.45);
      box-shadow: 0 0 0 3px rgba(196,91,77,0.15) inset;
    }
    .option.disabled { opacity: 0.6; cursor: default; }

    .equation.ok { color: var(--success); text-shadow: 0 0 12px rgba(74,165,100,0.35); }
    .equation.bad { color: var(--danger); text-shadow: 0 0 12px rgba(196,91,77,0.3); }

    footer {
      text-align: center;
      color: var(--muted);
      font-size: 0.85rem;
      padding: 20px;
    }

    /* Confetti overlay */
    #confettiCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 999;
      display: none;
    }

    #reward-layer {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 1100;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .reward-pop {
      position: absolute;
      font-size: clamp(48px, 12vw, 96px);
      transform: scale(0.2) translateY(20px);
      opacity: 0;
      text-shadow: 0 8px 20px rgba(120,90,60,0.35);
      animation: reward-pop 2400ms cubic-bezier(0.16, 1, 0.3, 1) forwards;
    }
    @keyframes reward-pop {
      0% { opacity: 0; transform: scale(0.2) translateY(30px); }
      18% { opacity: 1; transform: scale(1.05) translateY(-6px); }
      32% { transform: scale(0.95) translateY(0); }
      50% { transform: scale(1) translateY(0); }
      72% { opacity: 1; transform: scale(0.98) translateY(-10px); }
      100% { opacity: 0; transform: scale(1.1) translateY(-35px); }
    }

    #admin-toggle {
      position: fixed;
      bottom: 24px;
      right: 24px;
      padding: 8px 15px;
      border-radius: 8px;
      border: none;
      background: var(--admin-toggle-bg);
      color: #fff9f2;
      font-family: inherit;
      font-weight: 700;
      font-size: 0.95rem;
      cursor: pointer;
      box-shadow: 0 8px 18px rgba(120,90,60,0.35);
      z-index: 998;
      transition: transform 120ms ease, filter 120ms ease;
    }
    #admin-toggle:hover { filter: brightness(1.06); transform: translateY(-1px); }
    #admin-toggle:active { transform: translateY(0); }

    #admin-overlay[hidden] { display: none !important; }
    #admin-overlay {
      position: fixed;
      inset: 0;
      background: rgba(71,57,42,0.45);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      z-index: 1400;
      backdrop-filter: blur(3px);
    }

    #admin-panel {
      position: relative;
      width: min(100%, 440px);
      background: var(--admin-bg);
      border-radius: 12px;
      box-shadow: 0 20px 45px rgba(120,90,60,0.35);
      padding: 28px 24px 24px;
      display: grid;
      gap: 18px;
      max-height: min(92vh, 640px);
      overflow-y: auto;
      border: 1px solid rgba(186,152,112,0.25);
    }

    #admin-panel h2 {
      margin: 0;
      font-size: 1.4rem;
      font-weight: 800;
      letter-spacing: 0.3px;
      color: var(--text);
    }

    #admin-close {
      position: absolute;
      top: 14px;
      right: 18px;
      background: none;
      border: none;
      color: rgba(89,70,54,0.8);
      font-size: 1.4rem;
      line-height: 1;
      cursor: pointer;
      padding: 4px;
    }
    #admin-close:hover { color: rgba(63,47,35,0.95); }

    .admin-section {
      background: rgba(255,255,255,0.7);
      border-radius: 10px;
      border: 1px solid rgba(186,152,112,0.28);
      overflow: hidden;
    }
    .admin-section > summary {
      cursor: pointer;
      list-style: none;
      padding: 14px 18px;
      font-weight: 700;
      user-select: none;
      position: relative;
      color: var(--text);
    }
    .admin-section > summary::-webkit-details-marker { display: none; }
    .admin-section[open] > summary {
      border-bottom: 1px solid rgba(186,152,112,0.35);
    }

    .admin-fields {
      display: grid;
      gap: 14px;
      padding: 16px 18px 20px;
    }

    .admin-fields label {
      display: grid;
      gap: 6px;
      font-size: 0.9rem;
      color: rgba(77,60,46,0.85);
    }
    .admin-fields label span { font-weight: 600; }
    .admin-fields input[type="number"],
    .admin-fields input[type="text"],
    .admin-fields select,
    .admin-fields textarea {
      width: 100%;
      background: rgba(255,255,255,0.9);
      color: var(--text);
      border: 1px solid rgba(186,152,112,0.35);
      border-radius: 10px;
      padding: 10px 12px;
      font-family: inherit;
      font-size: 0.95rem;
      resize: vertical;
      min-height: 42px;
    }
    .admin-fields textarea { min-height: 120px; }
    .admin-fields input:focus,
    .admin-fields textarea:focus {
      outline: none;
      border-color: rgba(207,140,76,0.55);
      box-shadow: 0 0 0 2px rgba(207,140,76,0.18);
    }

    .admin-double {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    }

    .admin-fields .checkbox {
      display: grid;
      grid-auto-flow: column;
      grid-template-columns: auto 1fr;
      align-items: center;
      background: rgba(244,224,198,0.8);
      border: 1px solid rgba(186,152,112,0.4);
      border-radius: 10px;
      padding: 12px 14px;
      gap: 12px;
    }
    .admin-fields .checkbox input {
      width: 18px;
      height: 18px;
      accent-color: var(--primary);
    }

    .admin-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: flex-end;
    }

    @media (max-width: 720px) {
      #admin-toggle {
        right: 16px;
        bottom: 16px;
      }
      #admin-panel {
        width: min(100%, 420px);
        padding: 24px 20px 20px;
      }
    }
  </style>
  <link rel="icon" href="data:," />
  <meta name="color-scheme" content="dark light" />
  <meta name="description" content="Single-page multiplication tables practice game." />
  <meta name="theme-color" content="#c9823a" />
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">Times Tables Game</div>
      <div class="subtle">Practice multiplication</div>
    </header>

    <main class="container">
      <section class="game-card" aria-live="polite">
        <div class="score">
          <div>
            Correct: <strong id="correctCnt">0</strong> / <strong id="totalCnt">0</strong>
          </div>
          <div>
            Accuracy: <strong id="accuracy">‚Äî</strong>
          </div>
        </div>

        <div id="equation" class="equation" aria-label="problem">‚Äî</div>

        <div id="options" class="options"></div>

        <div class="btn-row">
          <button id="nextBtn" class="btn ghost" title="Next question">Next</button>
          <button id="resetBtn" class="btn secondary" title="Reset score">Reset Score</button>
        </div>

        <div class="collection">
          <h3 class="collection-title">Rewards</h3>
          <div id="collectionTray" class="collection-body" aria-live="polite"></div>
        </div>
      </section>
    </main>

    <footer>
      Built for quick practice ‚Äî open Setup to tweak ranges.
    </footer>
  </div>

  <canvas id="confettiCanvas"></canvas>
  <div id="reward-layer" aria-live="polite"></div>

  <div id="admin-overlay" hidden>
    <div id="admin-panel" role="dialog" aria-modal="true" aria-labelledby="admin-title" tabindex="-1">
      <button id="admin-close" type="button" aria-label="Close setup">√ó</button>
      <h2 id="admin-title">Setup</h2>
      <form id="admin-form" novalidate>
        <details class="admin-section" open>
          <summary>Gameplay</summary>
          <div class="admin-fields">
            <div class="admin-double">
              <label>
                <span>A min</span>
                <input id="game-a-min" type="number" min="0" step="1" />
              </label>
              <label>
                <span>A max</span>
                <input id="game-a-max" type="number" min="0" step="1" />
              </label>
            </div>
            <div class="admin-double">
              <label>
                <span>B min</span>
                <input id="game-b-min" type="number" min="0" step="1" />
              </label>
              <label>
                <span>B max</span>
                <input id="game-b-max" type="number" min="0" step="1" />
              </label>
            </div>
            <div class="admin-double">
              <label>
                <span>Number of options</span>
                <select id="game-num-options">
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                  <option value="6">6</option>
                </select>
              </label>
            </div>
            <div class="admin-double">
              <label class="checkbox">
                <input id="game-auto-next" type="checkbox" />
                <span>Auto-advance</span>
              </label>
              <label class="checkbox">
                <input id="game-confetti" type="checkbox" />
                <span>Enable confetti</span>
              </label>
            </div>
          </div>
        </details>

        <details class="admin-section" open>
          <summary>Progress</summary>
          <div class="admin-fields">
            <label>
              <span>Accuracy threshold (%)</span>
              <input id="progress-acc-threshold" type="number" min="0" max="100" step="1" />
            </label>
            <label>
              <span>Attempt threshold</span>
              <input id="progress-attempt-threshold" type="number" min="0" step="1" />
            </label>
            <label>
              <span>Prize interval</span>
              <input id="progress-prize-interval" type="number" min="1" step="1" />
            </label>
          </div>
        </details>

        <details class="admin-section" open>
          <summary>Rewards</summary>
          <div class="admin-fields">
            <label>
              <span>Streak interval</span>
              <input id="reward-interval" type="number" min="1" step="1" />
            </label>
            <label>
              <span>Reward emojis (one per line)</span>
              <textarea id="reward-emojis" rows="4"></textarea>
            </label>
            <label class="checkbox">
              <input id="reward-unique" type="checkbox" />
              <span>Prevent duplicate rewards</span>
            </label>
          </div>
        </details>

        <details class="admin-section">
          <summary>Level editor</summary>
          <div class="admin-fields">
            <label>
              <span>Backgrounds (one per line)</span>
              <textarea id="backgrounds-list" rows="3"></textarea>
            </label>
          </div>
        </details>

        <div class="admin-actions">
          <button type="submit" class="btn">Save</button>
          <button type="button" id="admin-cancel" class="btn ghost">Cancel</button>
          <button type="button" id="admin-reset" class="btn secondary">Reset defaults</button>
        </div>
      </form>
    </div>
  </div>

  <button id="admin-toggle" type="button" aria-haspopup="dialog" aria-controls="admin-panel">‚öôÔ∏è Setup</button>

  <script>
    (async function() {
      const el = (id) => document.getElementById(id);

      const equationEl = el('equation');
      const optionsEl = el('options');
      const nextBtn = el('nextBtn');
      const resetBtn = el('resetBtn');
      const correctCntEl = el('correctCnt');
      const totalCntEl = el('totalCnt');
      const accuracyEl = el('accuracy');

      const confettiCanvas = el('confettiCanvas');

      const adminToggle = el('admin-toggle');
      const adminOverlay = el('admin-overlay');
      const adminPanel = el('admin-panel');
      const adminClose = el('admin-close');
      const adminForm = el('admin-form');
      const adminCancel = el('admin-cancel');
      const adminReset = el('admin-reset');
      const gameAMinEl = el('game-a-min');
      const gameAMaxEl = el('game-a-max');
      const gameBMinEl = el('game-b-min');
      const gameBMaxEl = el('game-b-max');
      const gameNumOptionsEl = el('game-num-options');
      const gameAutoNextEl = el('game-auto-next');
      const gameConfettiEl = el('game-confetti');
      const accThresholdEl = el('progress-acc-threshold');
      const attemptThresholdEl = el('progress-attempt-threshold');
      const prizeIntervalEl = el('progress-prize-interval');
      const backgroundsListEl = el('backgrounds-list');
      const rewardIntervalEl = el('reward-interval');
      const rewardEmojisEl = el('reward-emojis');
      const rewardUniqueEl = el('reward-unique');
      const rewardLayer = el('reward-layer');
      const collectionTray = el('collectionTray');

      const allowedCounts = [2, 3, 4, 6];
      function coerceCount(n) {
        n = Number(n) || 4;
        if (allowedCounts.includes(n)) return n;
        if (n === 5) return 6;
        const sorted = allowedCounts.slice().sort((a, b) => a - b);
        if (n <= sorted[0]) return sorted[0];
        if (n >= sorted[sorted.length - 1]) return sorted[sorted.length - 1];
        let best = sorted[0];
        let bestDiff = Math.abs(n - best);
        for (const v of sorted) {
          const d = Math.abs(n - v);
          if (d < bestDiff) { best = v; bestDiff = d; }
        }
        return best;
      }

      const SETTINGS_STORAGE_KEY = 'mtg-settings';
      const ADMIN_STORAGE_KEY = 'mtg-admin-settings';
      const CONFIG_PATH = 'config.json';
      const REWARD_STORAGE_KEY = 'mtg-reward-collection';

      const fallbackConfig = {
        levels: ['level_1.yaml', 'level_2.yaml'],
        backgrounds: ['img/cats.jpg', 'img/cats2.jpg'],
        defaults: {
          game: {
            aMin: 1,
            aMax: 12,
            bMin: 1,
            bMax: 12,
            numOptions: 4,
            autoNext: true,
            confettiEnabled: true,
          },
          progress: { accThreshold: 80, attemptThreshold: 10, prizeInterval: 5 },
          rewards: {
            streakInterval: 5,
            preventDuplicates: false,
            emojiPool: ['üèÜ','üéâ','üåü','üç¨','üß†'],
          },
        },
      };

      const deepClone = (obj) => JSON.parse(JSON.stringify(obj ?? {}));
      const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
      const toInt = (value, fallback, bounds = {}) => {
        const num = Math.round(Number(value));
        if (!Number.isFinite(num)) return fallback;
        const min = bounds.min ?? -Infinity;
        const max = bounds.max ?? Infinity;
        return clamp(num, min, max);
      };
      const toFloat = (value, fallback, bounds = {}) => {
        const num = Number(value);
        if (!Number.isFinite(num)) return fallback;
        const min = bounds.min ?? -Infinity;
        const max = bounds.max ?? Infinity;
        return clamp(num, min, max);
      };

      function normalizeConfig(raw) {
        const normalized = deepClone(fallbackConfig);
        if (!raw || typeof raw !== 'object') return normalized;

        if (Array.isArray(raw.levels)) {
          const levels = raw.levels.filter((v) => typeof v === 'string' && v.trim());
          if (levels.length) normalized.levels = levels;
        }

        if (Array.isArray(raw.backgrounds)) {
          const bgs = raw.backgrounds.filter((v) => typeof v === 'string' && v.trim());
          if (bgs.length) normalized.backgrounds = bgs;
        }

        if (raw.defaults && typeof raw.defaults === 'object') {
          if (raw.defaults.game && typeof raw.defaults.game === 'object') {
            const src = raw.defaults.game;
            const game = normalized.defaults.game;
            if (typeof src.aMin === 'number') game.aMin = Math.max(0, Math.floor(src.aMin));
            if (typeof src.aMax === 'number') game.aMax = Math.max(0, Math.floor(src.aMax));
            if (game.aMin > game.aMax) [game.aMin, game.aMax] = [game.aMax, game.aMin];
            if (typeof src.bMin === 'number') game.bMin = Math.max(0, Math.floor(src.bMin));
            if (typeof src.bMax === 'number') game.bMax = Math.max(0, Math.floor(src.bMax));
            if (game.bMin > game.bMax) [game.bMin, game.bMax] = [game.bMax, game.bMin];
            if (typeof src.numOptions !== 'undefined') game.numOptions = coerceCount(src.numOptions);
            if (typeof src.autoNext === 'boolean') game.autoNext = src.autoNext;
            if (typeof src.confettiEnabled === 'boolean') game.confettiEnabled = src.confettiEnabled;
          }
          if (raw.defaults.progress && typeof raw.defaults.progress === 'object') {
            const prog = raw.defaults.progress;
            normalized.defaults.progress.accThreshold = toInt(
              prog.accThreshold,
              normalized.defaults.progress.accThreshold,
              { min: 0, max: 100 }
            );
            normalized.defaults.progress.attemptThreshold = toInt(
              prog.attemptThreshold,
              normalized.defaults.progress.attemptThreshold,
              { min: 0 }
            );
            normalized.defaults.progress.prizeInterval = toInt(
              prog.prizeInterval,
              normalized.defaults.progress.prizeInterval,
              { min: 1 }
            );
          }
          if (raw.defaults.rewards && typeof raw.defaults.rewards === 'object') {
            const src = raw.defaults.rewards;
            const rewards = normalized.defaults.rewards;
            rewards.streakInterval = toInt(
              src.streakInterval,
              rewards.streakInterval,
              { min: 1 }
            );
            rewards.preventDuplicates = Boolean(src.preventDuplicates);
            let pool = [];
            if (Array.isArray(src.emojiPool)) {
              pool = src.emojiPool;
            } else if (typeof src.emojiPool === 'string') {
              pool = src.emojiPool.split(/[\r\n,]+/);
            }
            pool = pool
              .map((val) => typeof val === 'string' ? val.trim() : '')
              .filter(Boolean);
            if (pool.length) {
              rewards.emojiPool = Array.from(new Set(pool));
            }
          }
        }
        return normalized;
      }

      async function loadConfig() {
        try {
          const res = await fetch(CONFIG_PATH, { cache: 'no-store' });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          return normalizeConfig(data);
        } catch (err) {
          console.warn('[setup] Falling back to embedded config.json defaults.', err);
          return deepClone(fallbackConfig);
        }
      }

      function loadAdminOverrides() {
        try {
          const raw = localStorage.getItem(ADMIN_STORAGE_KEY);
          if (!raw) return null;
          const parsed = JSON.parse(raw);
          return (parsed && typeof parsed === 'object') ? parsed : null;
        } catch {
          return null;
        }
      }

      function applyAdminOverrides(state, overrides) {
        if (!overrides || typeof overrides !== 'object') return;
        if (overrides.game && typeof overrides.game === 'object') {
          const game = overrides.game;
          if (typeof game.aMin === 'number') state.game.aMin = Math.max(0, Math.floor(game.aMin));
          if (typeof game.aMax === 'number') state.game.aMax = Math.max(0, Math.floor(game.aMax));
          if (state.game.aMin > state.game.aMax) [state.game.aMin, state.game.aMax] = [state.game.aMax, state.game.aMin];
          if (typeof game.bMin === 'number') state.game.bMin = Math.max(0, Math.floor(game.bMin));
          if (typeof game.bMax === 'number') state.game.bMax = Math.max(0, Math.floor(game.bMax));
          if (state.game.bMin > state.game.bMax) [state.game.bMin, state.game.bMax] = [state.game.bMax, state.game.bMin];
          if (typeof game.numOptions !== 'undefined') state.game.numOptions = coerceCount(game.numOptions);
          if (typeof game.autoNext === 'boolean') state.game.autoNext = game.autoNext;
          if (typeof game.confettiEnabled === 'boolean') state.game.confettiEnabled = game.confettiEnabled;
        }
        if (overrides.progress && typeof overrides.progress === 'object') {
          state.progress.accThreshold = toInt(
            overrides.progress.accThreshold,
            state.progress.accThreshold,
            { min: 0, max: 100 }
          );
          state.progress.attemptThreshold = toInt(
            overrides.progress.attemptThreshold,
            state.progress.attemptThreshold,
            { min: 0 }
          );
          state.progress.prizeInterval = toInt(
            overrides.progress.prizeInterval,
            state.progress.prizeInterval,
            { min: 1 }
          );
        }
        if (Array.isArray(overrides.backgrounds)) {
          const cleaned = overrides.backgrounds
            .filter((v) => typeof v === 'string' && v.trim());
          state.backgrounds = cleaned;
        }
        if (overrides.rewards && typeof overrides.rewards === 'object') {
          const rewards = overrides.rewards;
          if (typeof rewards.streakInterval !== 'undefined') {
            state.rewards.streakInterval = toInt(
              rewards.streakInterval,
              state.rewards.streakInterval,
              { min: 1 }
            );
          }
          if (typeof rewards.preventDuplicates === 'boolean') {
            state.rewards.preventDuplicates = rewards.preventDuplicates;
          }
          if (Array.isArray(rewards.emojiPool)) {
            const cleaned = rewards.emojiPool
              .map((v) => typeof v === 'string' ? v.trim() : '')
              .filter(Boolean);
            if (cleaned.length) state.rewards.emojiPool = Array.from(new Set(cleaned));
          }
        }
      }

      let lastBodyOverflow = '';
      const config = await loadConfig();
      const adminState = {
        config,
        game: deepClone(config.defaults.game),
        progress: deepClone(config.defaults.progress),
        rewards: deepClone(config.defaults.rewards),
        backgrounds: config.backgrounds.slice(),
      };
      let currentBackground = null;

      applyAdminOverrides(adminState, loadAdminOverrides());

      function collectList(value) {
        return value
          .split(/\r?\n/)
          .map((line) => line.trim())
          .filter(Boolean);
      }

      function syncAdminForm() {
        if (!adminForm) return;
        if (gameAMinEl) gameAMinEl.value = String(adminState.game.aMin ?? '');
        if (gameAMaxEl) gameAMaxEl.value = String(adminState.game.aMax ?? '');
        if (gameBMinEl) gameBMinEl.value = String(adminState.game.bMin ?? '');
        if (gameBMaxEl) gameBMaxEl.value = String(adminState.game.bMax ?? '');
        if (gameNumOptionsEl) gameNumOptionsEl.value = String(adminState.game.numOptions ?? '');
        if (gameAutoNextEl) gameAutoNextEl.checked = !!adminState.game.autoNext;
        if (gameConfettiEl) gameConfettiEl.checked = !!adminState.game.confettiEnabled;
        accThresholdEl.value = String(adminState.progress.accThreshold ?? '');
        attemptThresholdEl.value = String(adminState.progress.attemptThreshold ?? '');
        prizeIntervalEl.value = String(adminState.progress.prizeInterval ?? '');
        backgroundsListEl.value = adminState.backgrounds.join('\n');
        if (rewardIntervalEl) rewardIntervalEl.value = String(adminState.rewards.streakInterval ?? '');
        if (rewardEmojisEl) rewardEmojisEl.value = adminState.rewards.emojiPool.join('\n');
        if (rewardUniqueEl) rewardUniqueEl.checked = !!adminState.rewards.preventDuplicates;
      }

      function gatherAdminFormValues() {
        const [aMin, aMax] = clampRange(
          toInt(gameAMinEl?.value, adminState.game.aMin, { min: 0 }),
          toInt(gameAMaxEl?.value, adminState.game.aMax, { min: 0 })
        );
        const [bMin, bMax] = clampRange(
          toInt(gameBMinEl?.value, adminState.game.bMin, { min: 0 }),
          toInt(gameBMaxEl?.value, adminState.game.bMax, { min: 0 })
        );
        const game = {
          aMin,
          aMax,
          bMin,
          bMax,
          numOptions: coerceCount(gameNumOptionsEl?.value ?? adminState.game.numOptions),
          autoNext: !!gameAutoNextEl?.checked,
          confettiEnabled: !!gameConfettiEl?.checked,
        };
        const progress = {
          accThreshold: toInt(
            accThresholdEl.value,
            adminState.progress.accThreshold,
            { min: 0, max: 100 }
          ),
          attemptThreshold: toInt(
            attemptThresholdEl.value,
            adminState.progress.attemptThreshold,
            { min: 0 }
          ),
          prizeInterval: toInt(
            prizeIntervalEl.value,
            adminState.progress.prizeInterval,
            { min: 1 }
          ),
        };
        const backgrounds = collectList(backgroundsListEl.value);
        let emojis = collectList(rewardEmojisEl?.value || '');
        if (!emojis.length) {
          emojis = adminState.rewards.emojiPool.slice();
        }
        const rewards = {
          streakInterval: toInt(
            rewardIntervalEl?.value,
            adminState.rewards.streakInterval,
            { min: 1 }
          ),
          preventDuplicates: !!rewardUniqueEl?.checked,
          emojiPool: Array.from(new Set(emojis)),
        };
        return { game, progress, rewards, backgrounds };
      }

      function saveAdminOverrides() {
        const payload = {
          game: { ...adminState.game },
          progress: { ...adminState.progress },
          rewards: { ...adminState.rewards, emojiPool: adminState.rewards.emojiPool.slice() },
          backgrounds: adminState.backgrounds.slice(),
        };
        try {
          localStorage.setItem(ADMIN_STORAGE_KEY, JSON.stringify(payload));
        } catch {}
      }

      function cssBackgroundValue(path) {
        const trimmed = path.trim();
        if (!trimmed) return null;
        const escaped = trimmed.replace(/(["\\])/g, '\\$1');
        return `url("${escaped}") center / cover fixed no-repeat`;
      }

      function applyBackground(preferExisting = true) {
        const rootStyle = document.documentElement.style;
        if (!adminState.backgrounds.length) {
          currentBackground = null;
          rootStyle.setProperty('--bg-image', 'none');
          return;
        }
        if (
          preferExisting &&
          currentBackground &&
          adminState.backgrounds.includes(currentBackground)
        ) {
          const existing = cssBackgroundValue(currentBackground);
          rootStyle.setProperty('--bg-image', existing ?? 'none');
          return;
        }
        const idx = Math.floor(Math.random() * adminState.backgrounds.length);
        currentBackground = adminState.backgrounds[idx];
        const value = cssBackgroundValue(currentBackground);
        rootStyle.setProperty('--bg-image', value ?? 'none');
      }

      function openAdminPanel() {
        if (!adminOverlay) return;
        syncAdminForm();
        adminOverlay.hidden = false;
        if (adminToggle) adminToggle.setAttribute('aria-expanded', 'true');
        lastBodyOverflow = document.body.style.overflow;
        document.body.style.overflow = 'hidden';
        requestAnimationFrame(() => {
          adminPanel?.focus();
        });
      }

      function closeAdminPanel() {
        if (!adminOverlay) return;
        adminOverlay.hidden = true;
        if (adminToggle) adminToggle.setAttribute('aria-expanded', 'false');
        document.body.style.overflow = lastBodyOverflow;
        adminToggle?.focus();
      }

      if (adminToggle) {
        adminToggle.setAttribute('aria-expanded', 'false');
        adminToggle.addEventListener('click', openAdminPanel);
      }
      adminClose?.addEventListener('click', closeAdminPanel);
      adminCancel?.addEventListener('click', (ev) => {
        ev.preventDefault();
        closeAdminPanel();
      });
      adminOverlay?.addEventListener('click', (ev) => {
        if (ev.target === adminOverlay) {
          closeAdminPanel();
        }
      });
      document.addEventListener('keydown', (ev) => {
        if (ev.key === 'Escape' && !(adminOverlay?.hidden ?? true)) {
          closeAdminPanel();
        }
      });

      adminReset?.addEventListener('click', () => {
        adminState.game = deepClone(adminState.config.defaults.game);
        adminState.progress = deepClone(adminState.config.defaults.progress);
        adminState.rewards = deepClone(adminState.config.defaults.rewards);
        adminState.backgrounds = adminState.config.backgrounds.slice();
        currentBackground = null;
        try {
          localStorage.removeItem(ADMIN_STORAGE_KEY);
        } catch {}
        clearRewardCollection({ persist: true, resetStreak: true });
        applyGameDefaults(adminState.game, { persistLocal: true, restartRound: true });
        applyRewardDefaults(adminState.rewards, { persistLocal: true, restartStreak: true });
        syncAdminForm();
        applyBackground(false);
      });

      adminForm?.addEventListener('submit', (ev) => {
        ev.preventDefault();
        const next = gatherAdminFormValues();
        adminState.game = next.game;
        adminState.progress = next.progress;
        adminState.rewards = next.rewards;
        adminState.backgrounds = next.backgrounds;
        saveAdminOverrides();
        applyGameDefaults(adminState.game, { persistLocal: true, restartRound: true });
        applyRewardDefaults(adminState.rewards, { persistLocal: true });
        applyBackground(false);
        closeAdminPanel();
      });

      applyBackground(false);
      syncAdminForm();

      const state = {
        aMin: typeof adminState.game.aMin === 'number' ? adminState.game.aMin : 1,
        aMax: typeof adminState.game.aMax === 'number' ? adminState.game.aMax : 12,
        bMin: typeof adminState.game.bMin === 'number' ? adminState.game.bMin : 1,
        bMax: typeof adminState.game.bMax === 'number' ? adminState.game.bMax : 12,
        numOptions: coerceCount(
          typeof adminState.game.numOptions !== 'undefined'
            ? adminState.game.numOptions
            : 4
        ),
        autoNext: typeof adminState.game.autoNext === 'boolean' ? adminState.game.autoNext : true,
        correct: 0,
        total: 0,
        currentA: null,
        currentB: null,
        answered: false,
        nextTimeout: null,
        confettiEnabled: typeof adminState.game.confettiEnabled === 'boolean'
          ? adminState.game.confettiEnabled
          : true,
      };

      const rewardState = {
        streak: 0,
        interval: Math.max(1, adminState.rewards.streakInterval || 5),
        preventDuplicates: !!adminState.rewards.preventDuplicates,
        pool: Array.isArray(adminState.rewards.emojiPool) && adminState.rewards.emojiPool.length
          ? adminState.rewards.emojiPool.slice()
          : fallbackConfig.defaults.rewards.emojiPool.slice(),
        collection: new Map(),
        order: [],
        animationDuration: 2400,
      };

      applyGameDefaults(adminState.game);
      hydrateRewardCollection();
      applyRewardDefaults(adminState.rewards);

      const confetti = (() => {
        let ctx = null;
        let anim = null;
        let startTime = 0;
        let duration = 2400;
        let particles = [];

        const colors = ['#22d3ee', '#38bdf8', '#ffd166', '#22c55e', '#fb3b3b', '#a78bfa', '#f59e0b', '#ff7ac6'];

        function resize() {
          if (!confettiCanvas) return;
          const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
          confettiCanvas.width = Math.floor(window.innerWidth * dpr);
          confettiCanvas.height = Math.floor(window.innerHeight * dpr);
          ctx = confettiCanvas.getContext('2d');
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function makeParticles(n) {
          particles = [];
          for (let i = 0; i < n; i++) {
            const x = Math.random() * window.innerWidth;
            const y = -Math.random() * window.innerHeight * 0.2;
            const size = 6 + Math.random() * 8;
            const vx = (Math.random() - 0.5) * 2.2;
            const vy = 1 + Math.random() * 2.5;
            const ay = 0.04 + Math.random() * 0.06;
            const rot = Math.random() * Math.PI * 2;
            const vr = (Math.random() - 0.5) * 0.25;
            const color = colors[i % colors.length];
            particles.push({ x, y, vx, vy, ay, size, rot, vr, color, life: 0 });
          }
        }

        function step(ts) {
          if (!startTime) startTime = ts;
          const elapsed = ts - startTime;
          ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
          const t = Math.min(1, elapsed / duration);
          for (const p of particles) {
            p.vy += p.ay;
            p.x += p.vx;
            p.y += p.vy;
            p.rot += p.vr;
            p.life = t;
            const fade = t < 0.7 ? 1 : 1 - (t - 0.7) / 0.3;
            ctx.save();
            ctx.globalAlpha = Math.max(0, Math.min(1, fade));
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rot);
            const w = p.size * 1.2;
            const h = p.size * 0.9;
            ctx.fillStyle = p.color;
            ctx.fillRect(-w / 2, -h / 2, w, h);
            ctx.restore();
          }
          if (elapsed < duration) {
            anim = requestAnimationFrame(step);
          } else {
            cancelAnimationFrame(anim);
            anim = null;
            startTime = 0;
            particles = [];
            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
            confettiCanvas.style.display = 'none';
          }
        }

        function burst(n = 120) {
          if (!confettiCanvas) return;
          if (anim) {
            cancelAnimationFrame(anim);
            anim = null;
          }
          resize();
          makeParticles(n);
          startTime = 0;
          confettiCanvas.style.display = 'block';
          anim = requestAnimationFrame(step);
        }

        window.addEventListener('resize', () => { if (anim) resize(); });
        return { burst };
      })();

      try {
        const saved = JSON.parse(localStorage.getItem(SETTINGS_STORAGE_KEY) || '{}');
        if (saved && typeof saved === 'object' && Object.keys(saved).length) {
          applyGameDefaults({
            aMin: saved.aMin,
            aMax: saved.aMax,
            bMin: saved.bMin,
            bMax: saved.bMax,
            numOptions: saved.numOptions,
            autoNext: saved.autoNext,
            confettiEnabled: saved.confettiEnabled,
          });
          Object.assign(adminState.game, {
            aMin: state.aMin,
            aMax: state.aMax,
            bMin: state.bMin,
            bMax: state.bMax,
            numOptions: state.numOptions,
            autoNext: state.autoNext,
            confettiEnabled: state.confettiEnabled,
          });
          syncAdminForm();
        }
      } catch {}

      function clampRange(minV, maxV) {
        let min = Math.max(0, Math.floor(minV));
        let max = Math.max(0, Math.floor(maxV));
        if (min > max) [min, max] = [max, min];
        return [min, max];
      }

      function persistUserSettings() {
        try {
          localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify({
            aMin: state.aMin, aMax: state.aMax,
            bMin: state.bMin, bMax: state.bMax,
            numOptions: state.numOptions,
            autoNext: state.autoNext,
            confettiEnabled: state.confettiEnabled,
          }));
        } catch {}
      }

      function applyGameDefaults(game, { persistLocal = false, restartRound = false } = {}) {
        if (!game) return;
        const [aMin, aMax] = clampRange(
          toInt(game.aMin, state.aMin, { min: 0 }),
          toInt(game.aMax, state.aMax, { min: 0 })
        );
        const [bMin, bMax] = clampRange(
          toInt(game.bMin, state.bMin, { min: 0 }),
          toInt(game.bMax, state.bMax, { min: 0 })
        );

        state.aMin = aMin;
        state.aMax = aMax;
        state.bMin = bMin;
        state.bMax = bMax;
        state.numOptions = coerceCount(typeof game.numOptions !== 'undefined' ? game.numOptions : state.numOptions);
        state.autoNext = typeof game.autoNext === 'boolean' ? game.autoNext : !!state.autoNext;
        state.confettiEnabled = typeof game.confettiEnabled === 'boolean' ? game.confettiEnabled : !!state.confettiEnabled;

        if (persistLocal) persistUserSettings();
        if (restartRound) {
          clearTimers();
          newRound();
        }
      }

      function updateCollectionTray() {
        if (!collectionTray) return;
        collectionTray.innerHTML = '';
        const visible = rewardState.order.filter((emoji) => rewardState.collection.has(emoji));
        if (!visible.length) {
          const empty = document.createElement('div');
          empty.className = 'collection-empty';
          empty.textContent = 'Keep a streak going to earn new reward emojis.';
          collectionTray.appendChild(empty);
          return;
        }
        for (const emoji of visible) {
          const count = rewardState.collection.get(emoji) || 0;
          const chip = document.createElement('span');
          chip.className = 'collection-item';
          const emojiSpan = document.createElement('span');
          emojiSpan.className = 'emoji';
          emojiSpan.textContent = emoji;
          chip.appendChild(emojiSpan);
          if (count > 1) {
            const countSpan = document.createElement('span');
            countSpan.className = 'count';
            countSpan.textContent = `√ó${count}`;
            chip.appendChild(countSpan);
          }
          collectionTray.appendChild(chip);
        }
      }

      function hydrateRewardCollection() {
        rewardState.collection = new Map();
        rewardState.order = [];
        try {
          const raw = JSON.parse(localStorage.getItem(REWARD_STORAGE_KEY) || '[]');
          if (Array.isArray(raw)) {
            for (const entry of raw) {
              let emoji = '';
              let count = 1;
              if (Array.isArray(entry)) {
                [emoji, count] = entry;
              } else if (entry && typeof entry === 'object') {
                emoji = entry.emoji;
                count = entry.count;
              }
              if (typeof emoji !== 'string') continue;
              const trimmed = emoji.trim();
              if (!trimmed) continue;
              const qty = Math.max(1, Number(count) || 1);
              rewardState.collection.set(trimmed, qty);
              if (!rewardState.order.includes(trimmed)) {
                rewardState.order.push(trimmed);
              }
            }
          }
        } catch {}
        updateCollectionTray();
      }

      function saveRewardCollection() {
        const payload = rewardState.order
          .filter((emoji) => rewardState.collection.has(emoji))
          .map((emoji) => [emoji, rewardState.collection.get(emoji)]);
        try {
          localStorage.setItem(REWARD_STORAGE_KEY, JSON.stringify(payload));
        } catch {}
      }

      function clearRewardCollection({ persist = true, resetStreak = true } = {}) {
        rewardState.collection = new Map();
        rewardState.order = [];
        if (resetStreak) rewardState.streak = 0;
        if (persist) saveRewardCollection();
        updateCollectionTray();
      }

      function applyRewardDefaults(rewards, { persistLocal = false, restartStreak = false } = {}) {
        if (!rewards) return;
        rewardState.interval = Math.max(1, toInt(
          rewards.streakInterval,
          rewardState.interval,
          { min: 1 }
        ));
        rewardState.preventDuplicates = !!rewards.preventDuplicates;
        const poolSource = Array.isArray(rewards.emojiPool) && rewards.emojiPool.length
          ? rewards.emojiPool
          : fallbackConfig.defaults.rewards.emojiPool;
        rewardState.pool = Array.from(new Set(
          poolSource
            .map((val) => typeof val === 'string' ? val.trim() : '')
            .filter(Boolean)
        ));
        if (!rewardState.pool.length) {
          rewardState.pool = fallbackConfig.defaults.rewards.emojiPool.slice();
        }
        if (restartStreak) rewardState.streak = 0;
        if (persistLocal) saveRewardCollection();
        updateCollectionTray();
      }

      function pickRewardEmoji() {
        if (!rewardState.pool.length) return null;
        let choices = rewardState.pool;
        if (rewardState.preventDuplicates) {
          const unseen = rewardState.pool.filter((emoji) => !rewardState.collection.has(emoji));
          if (unseen.length) choices = unseen;
        }
        if (!choices.length) return null;
        const idx = Math.floor(Math.random() * choices.length);
        return choices[idx];
      }

      function playRewardAudio() {
        // Hook: designers can wire optional audio here.
      }

      function showRewardAnimation(emoji) {
        if (!rewardLayer) return;
        const node = document.createElement('span');
        node.className = 'reward-pop';
        node.textContent = emoji;
        rewardLayer.appendChild(node);
        const duration = rewardState.animationDuration || 2400;
        setTimeout(() => {
          node.remove();
        }, duration + 200);
      }

      function emitRewardEvent(detail) {
        document.dispatchEvent(new CustomEvent('reward:earned', { detail }));
      }

      function awardReward(emoji) {
        if (!emoji) return;
        const current = rewardState.collection.get(emoji) || 0;
        rewardState.collection.set(emoji, current + 1);
        if (!rewardState.order.includes(emoji)) {
          rewardState.order.push(emoji);
        }
        saveRewardCollection();
        updateCollectionTray();
        showRewardAnimation(emoji);
        playRewardAudio();
        emitRewardEvent({ emoji, count: rewardState.collection.get(emoji), streak: rewardState.streak });
      }

      function handleStreakResult(isCorrect) {
        if (isCorrect) {
          rewardState.streak += 1;
          if (rewardState.interval > 0 && rewardState.streak % rewardState.interval === 0) {
            const emoji = pickRewardEmoji();
            awardReward(emoji);
          }
        } else {
          rewardState.streak = 0;
        }
      }

      const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

      function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      function generateOptions(a, b, count, aMin, aMax, bMin, bMax) {
        const correct = a * b;
        const wrongSet = new Set();

        for (let da = -1; da <= 1; da++) {
          for (let db = -1; db <= 1; db++) {
            const aa = a + da;
            const bb = b + db;
            if (aa === a && bb === b) continue;
            if (aa < aMin || aa > aMax || bb < bMin || bb > bMax) continue;
            const val = aa * bb;
            if (val !== correct) wrongSet.add(val);
          }
        }

        let wrongs = Array.from(wrongSet);
        shuffle(wrongs);
        wrongs = wrongs.slice(0, Math.max(0, count - 1));

        let guard = 0;
        while (wrongs.length < (count - 1) && guard++ < 200) {
          const aa = randInt(aMin, aMax);
          const bb = randInt(bMin, bMax);
          const val = aa * bb;
          if (val !== correct && !wrongs.includes(val)) wrongs.push(val);
        }

        const options = [correct, ...wrongs];
        return shuffle(options);
      }

      function formatAccuracy(c, t) {
        if (!t) return '‚Äî';
        const p = Math.round((c / t) * 100);
        return p + '%';
      }

      function updateScoreboard() {
        correctCntEl.textContent = String(state.correct);
        totalCntEl.textContent = String(state.total);
        accuracyEl.textContent = formatAccuracy(state.correct, state.total);
      }

      function clearEquationState() {
        equationEl.classList.remove('ok', 'bad');
      }

      function clearTimers() {
        if (state.nextTimeout) {
          clearTimeout(state.nextTimeout);
          state.nextTimeout = null;
        }
      }

      function newRound() {
        clearTimers();
        state.answered = false;

        const a = randInt(state.aMin, state.aMax);
        const b = randInt(state.bMin, state.bMax);
        state.currentA = a;
        state.currentB = b;

        equationEl.textContent = `${a} √ó ${b} = ?`;
        clearEquationState();

        const opts = generateOptions(a, b, state.numOptions, state.aMin, state.aMax, state.bMin, state.bMax);

        optionsEl.innerHTML = '';
        optionsEl.classList.remove('opts-2','opts-3','opts-4','opts-6');
        const cls = 'opts-' + Math.max(2, Math.min(6, opts.length));
        optionsEl.classList.add(cls);
        opts.forEach(val => {
          const btn = document.createElement('button');
          btn.className = 'option';
          btn.textContent = String(val);
          btn.dataset.value = String(val);
          optionsEl.appendChild(btn);
        });

        optionsEl.querySelectorAll('.option').forEach(btn => {
          btn.addEventListener('click', onAnswerClick, { once: false });
        });
      }

      function disableOptions() {
        optionsEl.querySelectorAll('.option').forEach(btn => btn.classList.add('disabled'));
      }

      function onAnswerClick(ev) {
        if (state.answered) return;
        const val = Number(ev.currentTarget.dataset.value);
        const correctVal = state.currentA * state.currentB;
        const isCorrect = val === correctVal;
        state.answered = true;
        state.total += 1;
        if (isCorrect) state.correct += 1;

        const btn = ev.currentTarget;
        btn.classList.add(isCorrect ? 'correct' : 'wrong');
        if (!isCorrect) {
          const correctBtn = Array.from(optionsEl.querySelectorAll('.option'))
            .find(b => Number(b.dataset.value) === correctVal);
          if (correctBtn) correctBtn.classList.add('correct');
        }
        disableOptions();
        updateScoreboard();
        equationEl.textContent = `${state.currentA} √ó ${state.currentB} = ${correctVal}`;
        clearEquationState();
        equationEl.classList.add(isCorrect ? 'ok' : 'bad');

        handleStreakResult(isCorrect);

        if (isCorrect && state.confettiEnabled && state.correct > 0 && state.correct % 10 === 0) {
          confetti.burst(140);
        }

        if (state.autoNext) {
          clearTimers();
          state.nextTimeout = setTimeout(() => newRound(), isCorrect ? 900 : 1300);
        }
      }

      nextBtn.addEventListener('click', () => {
        newRound();
      });
      resetBtn.addEventListener('click', () => {
        state.correct = 0;
        state.total = 0;
        rewardState.streak = 0;
        clearRewardCollection({ persist: true, resetStreak: false });
        updateScoreboard();
      });
      updateScoreboard();
      newRound();
    })();
  </script>
</body>
</html>
